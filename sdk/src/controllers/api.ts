/**
 * Payment QueriesLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  PqQuerybydaterange200Response,
  pqQuerybydaterange200ResponseSchema,
} from '../models/pqQuerybydaterange200Response.js';
import {
  PqQuerybypaymentid200Response,
  pqQuerybypaymentid200ResponseSchema,
} from '../models/pqQuerybypaymentid200Response.js';
import {
  PqQueryhistoricalpayments200Response,
  pqQueryhistoricalpayments200ResponseSchema,
} from '../models/pqQueryhistoricalpayments200Response.js';
import { number, optional, string } from '../schema.js';
import { BaseApi } from './baseApi.js';
import { PqQuerybydaterange400ResponseError } from '../errors/pqQuerybydaterange400ResponseError.js';
import { PqQuerybypaymentid404ResponseError } from '../errors/pqQuerybypaymentid404ResponseError.js';
import { PqQueryhistoricalpayments400ResponseError } from '../errors/pqQueryhistoricalpayments400ResponseError.js';

export class Api extends BaseApi {
  /**
   * Query payments within a specified date time range.
   *
   * These payments can be filtered by currency, minAmount, maxAmount, last4Digits & receivedEvents.
   *
   * The API returns data for payments processed after 25 June 2024. For payments processed before then
   * use our [query for historical payments](/products/payment-queries/@v1/query-archive.md).
   *
   * @param accept
   * @param startDate            An ISO 8601 date-time supplied as a string. Filters for payments
   *                                              that occurred after the specified date-time. Must be supplied
   *                                              alongside endDate.
   * @param endDate              An ISO 8601 date-time supplied as a string. Filters for payments
   *                                              that occurred below the specified date-time. Must be supplied
   *                                              alongside startDate.
   * @param pageSize             The maximum number of payments to be returned in the response (max
   *                                              300).
   * @param currency             The three digit currency code.
   * @param minAmount            This is a whole number including the currency exponent (e.g. GBP has
   *                                              an exponent of 2, so for £2.50 supply:`250`).
   * @param maxAmount            This is a whole number including the currency exponent (e.g. GBP has
   *                                              an exponent of 2, so for £2.50 supply:`250`).
   * @param last4Digits          The last four digits of the card number.
   * @param entityReferences     Your entity reference(s).
   * @param receivedEvents       Name of the event.
   * @param transactionReference A unique reference generated by you, used to identify a payment
   *                                              throughout its lifecycle. This shouldn't be used in conjunction with
   *                                              the above fields. Use it as a single parameter to query data.
   * @return Response from the API call
   */
  async queryByDateRange(
    accept: string,
    startDate: string,
    endDate: string,
    pageSize?: number,
    currency?: string,
    minAmount?: number,
    maxAmount?: number,
    last4Digits?: string,
    entityReferences?: string,
    receivedEvents?: string,
    transactionReference?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PqQuerybydaterange200Response>> {
    const req = this.createRequest('GET', '/paymentQueries/payments');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      startDate: [startDate, string()],
      endDate: [endDate, string()],
      pageSize: [pageSize, optional(number())],
      currency: [currency, optional(string())],
      minAmount: [minAmount, optional(number())],
      maxAmount: [maxAmount, optional(number())],
      last4Digits: [last4Digits, optional(string())],
      entityReferences: [entityReferences, optional(string())],
      receivedEvents: [receivedEvents, optional(string())],
      transactionReference: [transactionReference, optional(string())],
    });
    req.header('Accept', mapped.accept);
    req.query('startDate', mapped.startDate);
    req.query('endDate', mapped.endDate);
    req.query('pageSize', mapped.pageSize);
    req.query('currency', mapped.currency);
    req.query('minAmount', mapped.minAmount);
    req.query('maxAmount', mapped.maxAmount);
    req.query('last4Digits', mapped.last4Digits);
    req.query('entityReferences', mapped.entityReferences);
    req.query('receivedEvents', mapped.receivedEvents);
    req.query('transactionReference', mapped.transactionReference);
    req.throwOn(400, PqQuerybydaterange400ResponseError, 'Bad request');
    req.authenticate([{ basicAuth: true }]);
    return req.callAsJson(pqQuerybydaterange200ResponseSchema, requestOptions);
  }

  /**
   * Retrieve a single payment by payment ID.
   *
   * The API returns detailed data for payments processed after 25 June 2024. For payments processed
   * before then use our [query for historical payments](/products/payment-queries/@v1/query-archive.md).
   *
   * @param accept
   * @param paymentId Unique identifier generated for each payment. Historic `paymentId` values in UUID
   *                            format.
   * @return Response from the API call
   */
  async retrieveByPaymentId(
    accept: string,
    paymentId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PqQuerybypaymentid200Response>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      paymentId: [paymentId, string()],
    });
    req.header('Accept', mapped.accept);
    req.appendTemplatePath`/paymentQueries/payments/${mapped.paymentId}`;
    req.throwOn(
      404,
      PqQuerybypaymentid404ResponseError,
      'The payment was not found.'
    );
    req.authenticate([{ basicAuth: true }]);
    return req.callAsJson(pqQuerybypaymentid200ResponseSchema, requestOptions);
  }

  /**
   * Query payments processed before 25 June 2024.
   *
   * Provide a `transactionReference` and `entityReference` for a payment to find the matching payment in
   * the archive.
   *
   * @param accept
   * @param transactionReference A unique reference generated by you, used to identify a payment throughout
   *                                       its lifecycle.
   * @param entityReference      A merchant entity.
   * @return Response from the API call
   */
  async queryArchivedPayments(
    accept: string,
    transactionReference: string,
    entityReference: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PqQueryhistoricalpayments200Response>> {
    const req = this.createRequest('GET', '/paymentQueries/archivedPayments');
    const mapped = req.prepareArgs({
      accept: [accept, string()],
      transactionReference: [transactionReference, string()],
      entityReference: [entityReference, string()],
    });
    req.header('Accept', mapped.accept);
    req.query('transactionReference', mapped.transactionReference);
    req.query('entityReference', mapped.entityReference);
    req.throwOn(400, PqQueryhistoricalpayments400ResponseError, 'Bad request');
    req.authenticate([{ basicAuth: true }]);
    return req.callAsJson(
      pqQueryhistoricalpayments200ResponseSchema,
      requestOptions
    );
  }
}
